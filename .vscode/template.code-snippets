{
	// Place your oj_env workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"multicase main": {
		"scope": "cpp",
		"prefix": [
			"#include",
			"main",
			"multi"
		],
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"using ld = long double;",
			"// https://space.bilibili.com/672328094",
			"",
			"int main() {",
			"\tcin.tie(nullptr)->sync_with_stdio(false);",
			"\tcout << fixed << setprecision(20);",
			"\tint T;",
			"\tcin >> T;",
			"\twhile (T--) {",
			"\t\t$0",
			"\t}",
			"}",
		],
		"description": "multicase main"
	},
	"singlecase main": {
		"scope": "cpp",
		"prefix": [
			"#include",
			"main",
			"single"
		],
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"using ld = long double;",
			"// https://space.bilibili.com/672328094",
			"",
			"int main() {",
			"\tcin.tie(nullptr)->sync_with_stdio(false);",
			"\tcout << fixed << setprecision(20);",
			"\t$0",
			"}",
		],
		"description": "singlecase main"
	},
	"read_n": {
		"scope": "cpp",
		"prefix": "n",
		"body": [
			"ll n;",
			"cin >> n;\n"
		],
		"description": "read_n"
	},
	"read_n_m": {
		"scope": "cpp",
		"prefix": "nm",
		"body": [
			"ll n, m;",
			"cin >> n >> m;\n"
		],
		"description": "read_n_m"
	},
	"read_array": {
		"scope": "cpp",
		"prefix": "a",
		"body": [
			"vector<${0:ll}> a(n);",
			"for (auto& x : a) cin >> x;\n"
		],
		"description": "read_array"
	},
	"read_string": {
		"scope": "cpp",
		"prefix": "s",
		"body": [
			"string ${0:s};",
			"cin >> ${0:s};"
		],
		"description": "read_string"
	},
	"read_graph": {
		"scope": "cpp",
		"prefix": [
			"g",
			"vector<vector<ll>> g(n);"
		],
		"body": [
			"vector<vector<ll>> g(n);",
			"for (int i = 0, u, v; i < ${0:n - 1}; i++) {",
			"\tcin >> u >> v, u--, v--;",
			"\tg[u].push_back(v), g[v].push_back(u);",
			"}\n"
		],
		"description": "read_graph"
	},
	"mod": {
		"scope": "cpp",
		"prefix": [
			"MOD",
			"Z"
		],
		"body": [
			"constexpr ll MOD = ${1|998244353,1e9+7|};",
			"",
			"ll norm(ll x) { return (x % MOD + MOD) % MOD; }",
			"template <class T>",
			"T power(T a, ll b, T res = 1) {",
			"\tfor (; b; b /= 2, (a *= a) %= MOD)",
			"\t\tif (b & 1) (res *= a) %= MOD;",
			"\treturn res;",
			"}",
			"struct Z {",
			"\tll x;",
			"\tZ(ll _x = 0) : x(norm(_x)) {}",
			"\tauto operator<=>(const Z &) const = default;",
			"\tZ operator-() const { return Z(norm(MOD - x)); }",
			"\tZ inv() const { return power(*this, MOD - 2); }",
			"\tZ &operator*=(const Z &rhs) { return x = x * rhs.x % MOD, *this; }",
			"\tZ &operator+=(const Z &rhs) { return x = norm(x + rhs.x), *this; }",
			"\tZ &operator-=(const Z &rhs) { return x = norm(x - rhs.x), *this; }",
			"\tZ &operator/=(const Z &rhs) { return *this *= rhs.inv(); }",
			"\tZ &operator%=(const ll &rhs) { return x %= rhs, *this; }",
			"\tfriend Z operator*(Z lhs, const Z &rhs) { return lhs *= rhs; }",
			"\tfriend Z operator+(Z lhs, const Z &rhs) { return lhs += rhs; }",
			"\tfriend Z operator-(Z lhs, const Z &rhs) { return lhs -= rhs; }",
			"\tfriend Z operator/(Z lhs, const Z &rhs) { return lhs /= rhs; }",
			"\tfriend Z operator%(Z lhs, const ll &rhs) { return lhs %= rhs; }",
			"\tfriend auto &operator>>(istream &i, Z &z) { return i >> z.x; }",
			"\tfriend auto &operator<<(ostream &o, const Z &z) { return o << z.x; }",
			"};"
		],
		"description": "mod"
	},
	"SegTree": {
		"scope": "cpp",
		"prefix": "SegTree",
		"body": [
			"struct SegTree {",
			"\tll n;",
			"\tvector<int> t;",
			"\tSegTree(ll _n) : n(_n), t(2 * n) {}",
			"\tvoid modify(ll p, int v) {",
			"\t\tt[p += n] += v;",
			"\t\tfor (p /= 2; p; p /= 2) t[p] = t[2 * p] + t[2 * p + 1];",
			"\t}",
			"\tint query(ll l, ll r) {",
			"\t\tint res = 0;",
			"\t\tfor (l += n, r += n; l < r; l /= 2, r /= 2) {",
			"\t\t\tif (l & 1) res += t[l++];",
			"\t\t\tif (r & 1) res += t[--r];",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};",
		],
		"description": "Plain SegTree"
	},
	"Node SegTree": {
		"scope": "cpp",
		"prefix": "SegTree",
		"body": [
			"struct Node {",
			"\tll v = 0, init = 0;",
			"};",
			"",
			"Node pull(const Node &a, const Node &b) {",
			"\tif (!a.init) return b;",
			"\tif (!b.init) return a;",
			"\tNode c;",
			"\treturn c;",
			"}",
			"",
			"struct SegTree {",
			"\tll n;",
			"\tvector<Node> t;",
			"\tSegTree(ll _n) : n(_n), t(2 * n){};",
			"\tvoid modify(ll p, const Node &v) {",
			"\t\tt[p += n] = v;",
			"\t\tfor (p /= 2; p; p /= 2) t[p] = pull(t[p * 2], t[p * 2 + 1]);",
			"\t}",
			"\tNode query(ll l, ll r) {",
			"\t\tNode left, right;",
			"\t\tfor (l += n, r += n; l < r; l /= 2, r /= 2) {",
			"\t\t\tif (l & 1) left = pull(left, t[l++]);",
			"\t\t\tif (r & 1) right = pull(t[--r], right);",
			"\t\t}",
			"\t\treturn pull(left, right);",
			"\t}",
			"};",
		],
		"description": "Node SegTree"
	},
	"Lazy SegTree": {
		"scope": "cpp",
		"prefix": "lazy",
		"body": [
			"struct Node {",
			"\tll one = 0, total = 0, lazy = -1;",
			"};",
			"",
			"Node pull(const Node &a, const Node &b) { return {a.one + b.one, a.total + b.total}; }",
			"",
			"struct SegTree {",
			"\tll n, h = 0;",
			"\tvector<Node> t;",
			"\tSegTree(ll _n) : n(_n), h((ll)log2(n)), t(n * 2) {}",
			"\tvoid apply(ll x, ll v) {",
			"\t\tif (v == 0) {",
			"\t\t\tt[x].one = 0;",
			"\t\t} else {",
			"\t\t\tt[x].one = t[x].total;",
			"\t\t}",
			"\t\tt[x].lazy = v;",
			"\t}",
			"\tvoid build(ll l) {",
			"\t\tfor (l = (l + n) / 2; l > 0; l /= 2) {",
			"\t\t\tif (t[l].lazy == -1) {",
			"\t\t\t\tt[l] = pull(t[l * 2], t[l * 2 + 1]);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tvoid push(ll l) {",
			"\t\tl += n;",
			"\t\tfor (ll s = h; s > 0; s--) {",
			"\t\t\tll i = l >> s;",
			"\t\t\tif (t[i].lazy != -1) {",
			"\t\t\t\tapply(2 * i, t[i].lazy);",
			"\t\t\t\tapply(2 * i + 1, t[i].lazy);",
			"\t\t\t}",
			"\t\t\tt[i].lazy = -1;",
			"\t\t}",
			"\t}",
			"\tvoid modify(ll l, ll r, int v) {",
			"\t\tpush(l), push(r - 1);",
			"\t\tll l0 = l, r0 = r;",
			"\t\tfor (l += n, r += n; l < r; l /= 2, r /= 2) {",
			"\t\t\tif (l & 1) apply(l++, v);",
			"\t\t\tif (r & 1) apply(--r, v);",
			"\t\t}",
			"\t\tbuild(l0), build(r0 - 1);",
			"\t}",
			"\tNode query(ll l, ll r) {",
			"\t\tpush(l), push(r - 1);",
			"\t\tNode left, right;",
			"\t\tfor (l += n, r += n; l < r; l /= 2, r /= 2) {",
			"\t\t\tif (l & 1) left = pull(left, t[l++]);",
			"\t\t\tif (r & 1) right = pull(t[--r], right);",
			"\t\t}",
			"\t\treturn pull(left, right);",
			"\t}",
			"};",
		],
		"description": "Lazy SegTree"
	},
	"Persistent SegTree": {
		"scope": "cpp",
		"prefix": [
			"SegTree",
			"persistent"
		],
		"body": [
			"struct Node {",
			"\tint lc = 0, rc = 0, p = 0;",
			"};",
			"",
			"struct SegTree {",
			"\tvector<Node> t = {{}};  // init all",
			"\tSegTree() = default;",
			"\tSegTree(int n) { t.reserve(n * 20); }",
			"\tint modify(int p, int l, int r, int x, int v) {",
			"\t\t// p: original node, update a[x] -> v",
			"\t\tt.push_back(t[p]);",
			"\t\tint u = (int)t.size() - 1;",
			"\t\tif (r - l == 1) {",
			"\t\t\tt[u].p = v;",
			"\t\t} else {",
			"\t\t\tint m = (l + r) / 2;",
			"\t\t\tif (x < m) {",
			"\t\t\t\tt[u].lc = modify(t[p].lc, l, m, x, v);",
			"\t\t\t\tt[u].rc = t[p].rc;",
			"\t\t\t} else {",
			"\t\t\t\tt[u].lc = t[p].lc;",
			"\t\t\t\tt[u].rc = modify(t[p].rc, m, r, x, v);",
			"\t\t\t}",
			"\t\t\tt[u].p = t[t[u].lc].p + t[t[u].rc].p;",
			"\t\t}",
			"\t\treturn u;",
			"\t}",
			"\tint query(int p, int l, int r, int x, int y) {",
			"\t\t// query sum a[x]...a[y-1] rooted at p",
			"\t\t// t[p] holds the info of [l, r)",
			"\t\tif (x <= l && r <= y) return t[p].p;",
			"\t\tint m = (l + r) / 2, res = 0;",
			"\t\tif (x < m) res += query(t[p].lc, l, m, x, y);",
			"\t\tif (y > m) res += query(t[p].rc, m, r, x, y);",
			"\t\treturn res;",
			"\t}",
			"};",
		],
		"description": "Persistent SegTree"
	},
	"union find": {
		"scope": "cpp",
		"prefix": [
			"p",
			"union"
		],
		"body": [
			"vector<ll> p(n);",
			"iota(p.begin(), p.end(), 0);",
			"function<ll(ll)> find = [&](ll x) { return x == p[x] ? x : (p[x] = find(p[x])); };",
			"auto merge = [&](ll x, ll y) { return p[find(x)] = p[find(y)]; };",
		],
		"description": "union find"
	},
	"primes": {
		"scope": "cpp",
		"prefix": "prime",
		"body": [
			"vector<int> min_primes(MAX_N), primes;",
			"primes.reserve(1e5);",
			"for (int i = 2; i < MAX_N; i++) {",
			"\tif (!min_primes[i]) min_primes[i] = i, primes.push_back(i);",
			"\tfor (auto& p : primes) {",
			"\t\tif (p * i >= MAX_N) break;",
			"\t\tmin_primes[p * i] = p;",
			"\t\tif (i % p == 0) break;",
			"\t}",
			"}",
		],
		"description": "linear prime sieve"
	},
	"fac": {
		"scope": "cpp",
		"prefix": [
			"fac",
			"binom"
		],
		"body": [
			"vector<Z> f(MAX_N, 1), rf(MAX_N, 1);",
			"for (int i = 2; i < MAX_N; i++) f[i] = f[i - 1] * i % MOD;",
			"rf[MAX_N - 1] = power(f[MAX_N - 1], MOD - 2);",
			"for (int i = MAX_N - 2; i > 1; i--) rf[i] = rf[i + 1] * (i + 1) % MOD;",
			"auto binom = [&](int n, int r) -> Z {",
			"\tif (n < 0 || r < 0 || n < r) return 0;",
			"\treturn f[n] * rf[n - r] * rf[r];",
			"};",
		],
		"description": "factorial"
	},
	"rng mt19937_64": {
		"scope": "cpp",
		"prefix": [
			"rng",
			"mt19937_64"
		],
		"body": [
			"mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());"
		],
		"description": "rng mt19937_64"
	},
	"compress": {
		"scope": "cpp",
		"prefix": [
			"compress",
		],
		"body": [
			"auto compress = ${0:a};",
			"sort(compress.begin(), compress.end());",
			"compress.erase(unique(compress.begin(), compress.end()), compress.end());",
			"for (auto& x : ${0:a}) x = lower_bound(compress.begin(), compress.end(), x) - compress.begin();",
		],
		"description": "compress"
	},
	"quick io": {
		"scope": "cpp",
		"prefix": [
			"io",
		],
		"body": [
			"namespace io {",
			"constexpr int SIZE = 1 << 16;",
			"char buf[SIZE], *head, *tail;",
			"char get_char() {",
			"\tif (head == tail) tail = (head = buf) + fread(buf, 1, SIZE, stdin);",
			"\treturn *head++;",
			"}",
			"ll read() {",
			"\tll x = 0, f = 1;",
			"\tchar c = get_char();",
			"\tfor (; !isdigit(c); c = get_char()) (c == '-') && (f = -1);",
			"\tfor (; isdigit(c); c = get_char()) x = x * 10 + c - '0';",
			"\treturn x * f;",
			"}",
			"string read_s() {",
			"\tstring str;",
			"\tchar c = get_char();",
			"\twhile (c == ' ' || c == '\\n' || c == '\\r') c = get_char();",
			"\twhile (c != ' ' && c != '\\n' && c != '\\r') str += c, c = get_char();",
			"\treturn str;",
			"}",
			"void print(int x) {",
			"\tif (x > 9) print(x / 10);",
			"\tputchar(x % 10 | '0');",
			"}",
			"void println(int x) { print(x), putchar('\\n'); }",
			"struct Read {",
			"\tRead& operator>>(auto& x) { return x = read(), *this; }",
			"\tRead& operator>>(long double& x) { return x = stold(read_s()), *this; }",
			"} in;",
			"}  // namespace io",
		],
		"description": "quick io"
	}
}
